<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NEET CAP PDF Extractor</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

<style>
:root{
    --primary:#1f3a5f;
    --secondary:#4b79a1;
    --bg:#f4f6f8;
    --card:#ffffff;
    --success:#2e7d32;
    --error:#d32f2f;
    --border:#e0e0e0;
}

*{
    box-sizing:border-box;
    font-family: "Segoe UI", Roboto, Arial, sans-serif;
}

body{
    margin:0;
    background:linear-gradient(135deg,#eef2f7,#f9fbfd);
    padding:20px;
}

.container{
    max-width:1200px;
    margin:auto;
}

.header{
    text-align:center;
    margin-bottom:20px;
}

.header h2{
    margin:0;
    color:var(--primary);
    font-weight:600;
}

.card{
    background:var(--card);
    border-radius:12px;
    box-shadow:0 8px 20px rgba(0,0,0,0.06);
    padding:20px;
}

.controls{
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    align-items:center;
    justify-content:space-between;
    margin-bottom:15px;
}

.controls-left{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
}

input[type="file"]{
    padding:8px;
    border:1px solid var(--border);
    border-radius:6px;
    background:#fff;
}

button{
    padding:10px 18px;
    border:none;
    border-radius:6px;
    background:var(--primary);
    color:#fff;
    font-size:14px;
    cursor:pointer;
    transition:all .25s ease;
}

button:hover{
    background:var(--secondary);
}

button:disabled{
    background:#9aa9b8;
    cursor:not-allowed;
}

.status{
    margin:10px 0;
    font-size:14px;
}

.loading{color:#555}
.success{color:var(--success);font-weight:600}
.error{color:var(--error);font-weight:600}

/* ===== Table ===== */
.table-wrapper{
    width:100%;
    overflow-x:auto;
    margin-top:10px;
}

table{
    width:100%;
    border-collapse:collapse;
    min-width:600px;
}

th,td{
    padding:10px 12px;
    border:1px solid var(--border);
    font-size:14px;
    text-align:left;
}

th{
    background:var(--primary);
    color:#fff;
    position:sticky;
    top:0;
    z-index:1;
}

tr:nth-child(even){
    background:#f7f9fc;
}

/* ===== Mobile ===== */
@media(max-width:768px){
    .controls{
        flex-direction:column;
        align-items:stretch;
    }

    .controls-left{
        width:100%;
    }

    button{
        width:100%;
    }

    input[type="file"]{
        width:100%;
    }

    .header h2{
        font-size:20px;
    }
}
</style>
<base target="_blank">
</head>

<body>

<div class="container">

    <div class="header">
        <h2>Medical PDF Extractor</h2>
        <p style="color:#666;font-size:14px;margin-top:5px;">Extracts and filters NEET CAP data | Removes records without college assignments</p>
    </div>

    <div class="card">

        <div class="controls">
            <div class="controls-left">
                <input type="file" id="pdfFile" accept="application/pdf">
                <button onclick="downloadCSV()" id="downloadBtn" disabled>Download CSV</button>
                <button onclick="clearTable()">Clear</button>
            </div>
        </div>

        <div id="status" class="status loading">Select PDF to begin</div>

        <div class="table-wrapper">
            <table id="dataTable" style="display:none">
                <thead>
                    <tr>
                        <th>AIR</th>
                        <th>Gender</th>
                        <th>Category</th>
                        <th>College Code</th>
                        <th>College Name</th>
                    </tr>
                </thead>
                <tbody id="tableBody"></tbody>
            </table>
        </div>

    </div>

</div>

<script>
pdfjsLib.GlobalWorkerOptions.workerSrc =
"https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

let extractedData = [];

document.getElementById("pdfFile").addEventListener("change", readPDF);

async function readPDF(e){
    const file = e.target.files[0];
    if(!file) return;

    document.getElementById("status").innerText="Reading PDF...";
    document.getElementById("status").className="loading";
    
    const reader=new FileReader();

    reader.onload=async()=>{
        try{
            const pdf=await pdfjsLib.getDocument(new Uint8Array(reader.result)).promise;
            let fullText="";

            for(let i=1;i<=pdf.numPages;i++){
                const page=await pdf.getPage(i);
                const content=await page.getTextContent();
                fullText+=content.items.map(i=>i.str).join(" ")+" ";
            }
            extractData(fullText);
        }catch(err){
            document.getElementById("status").innerText="PDF Error: " + err.message;
            document.getElementById("status").className="error";
            console.error(err);
        }
    };
    reader.readAsArrayBuffer(file);
}

function extractData(text){
    extractedData=[];
    document.getElementById("tableBody").innerHTML="";

    // Normalize whitespace but preserve newlines for line-by-line parsing
    text=text.replace(/\s+/g," ").trim();

    // Split into lines and process each line
    const lines = text.split(/(?=\d+\s+\d+\s+\d{10}\s+\d{9})/);

    let totalRecords = 0;

    for(let line of lines){
        line = line.trim();
        if(!line) continue;

        const result = extractFromLine(line);
        if(result){
            totalRecords++;
            
            // Clean up category
            let cleanCategory = result.category.replace(/\s+ORPHAN.*$/i, "").trim();

            // Fix concatenated categories like "SEBCORP-C" -> "SEBC ORP-C"
            // Includes ORP-A, ORP-B, ORP-C
            cleanCategory = cleanCategory.replace(/\b(SEBC|SOBC|OBC|SC|ST|EWS|VJA|NTB|NTC|NTD|OPEN)(ORP-[A-C]|ORP-B|ORP)\b/g, "$1 $2");
            
            // Fix concatenated modifiers like "SEBCHA" -> "SEBC HA"
            cleanCategory = cleanCategory.replace(/\b(SEBC|SOBC|OBC|SC|ST|EWS|VJA|NTB|NTC|NTD|OPEN)(HA|W|D1|D2|D3|IQ|I\.Q\.|PWD|PH|EMD|EMR)\b/gi, "$1 $2");

            // Parse category
            const parsedCategory = parseCategory(cleanCategory);

            // Clean college name
            const collegeName = cleanCollegeName(result.college_name);
            const collegeCode = result.college_code || "";

            // Check if college is valid (skip if not)
            if(!hasValidCollege(collegeName, collegeCode)) {
                continue;
            }
            
            extractedData.push({
                air: result.air,
                name: result.name,
                gender: result.gender,
                category: parsedCategory,
                rawCategory: cleanCategory,
                collegeCode: collegeCode,
                collegeName: collegeName
            });
        }
    }

    if(extractedData.length===0){
        document.getElementById("status").innerText="No data found. Please check PDF format.";
        document.getElementById("status").className="error";
        return;
    }

    // Sort by AIR
    extractedData.sort((a,b)=>parseInt(a.air)-parseInt(b.air));

    // Display data
    extractedData.forEach((r, index)=>{
        const tr=document.createElement("tr");
        tr.innerHTML=`
            <td><strong>${r.air}</strong></td>
            <td>${r.gender}</td>
            <td title="Raw: ${r.rawCategory}">${r.category}</td>
            <td>${r.collegeCode}</td>
            <td>${r.collegeName}</td>
        `;
        document.getElementById("tableBody").appendChild(tr);
    });

    document.getElementById("dataTable").style.display="table";
    document.getElementById("downloadBtn").disabled=false;
    document.getElementById("status").innerText=`Extracted ${extractedData.length} records successfully!`;
    document.getElementById("status").className="success";
}

function hasValidCollege(collegeName, collegeCode) {
    if (!collegeName || collegeName.trim() === "") return false;
    
    const upperName = collegeName.toUpperCase();
    const invalidPatterns = [
        "CHOICE NOT AVAILABLE",
        "NOT AVAILABLE",
        "NOT PROVIDED",
        "NO COLLEGE",
        "N/A",
        "NIL",
        "NULL",
        "---",
        "--",
        "TO BE ALLOTTED",
        "NOT ALLOTTED",
        "NOT ASSIGNED"
    ];
    
    for (let pattern of invalidPatterns) {
        if (upperName.includes(pattern)) return false;
    }
    
    // Check if it's just numbers or special characters
    if (upperName.replace(/[^A-Z]/g, '').length < 2) return false;
    
    // Check college code
    if (collegeCode) {
        const code = collegeCode.trim();
        if (code === "" || code === "0" || code === "000" || code === "N/A") return false;
    }
    
    return true;
}

function extractFromLine(line){
    // Parse a single line of PDF data
    const parts = line.trim().split(/\s+/);

    // Find all numbers and their positions
    const numbers = [];
    for(let i=0; i<parts.length; i++){
        if(/^\d+$/.test(parts[i])){
            numbers.push({pos: i, num: parts[i], len: parts[i].length});
        }
    }

    // Need at least 4 numbers: Serial, AIR, NEET(10), Form(9)
    if(numbers.length < 4) return null;

    // Find NEET roll (10 digits) and Form (9 digits)
    let neetIdx = -1;
    let formIdx = -1;

    for(let i=0; i<numbers.length; i++){
        if(numbers[i].len === 10 && neetIdx === -1){
            neetIdx = i;
        } else if(numbers[i].len === 9 && formIdx === -1 && neetIdx !== -1 && i > neetIdx){
            formIdx = i;
            break;
        }
    }

    if(neetIdx === -1 || formIdx === -1) return null;

    // Get Serial and AIR (numbers before NEET)
    const serial = neetIdx >= 2 ? numbers[neetIdx-2].num : "";
    const air = neetIdx >= 1 ? numbers[neetIdx-1].num : "";
    const neet = numbers[neetIdx].num;
    const form = numbers[formIdx].num;

    // Find Gender (M or F) after Form number
    let gender = "";
    let genderPos = -1;

    for(let i=numbers[formIdx].pos+1; i<parts.length; i++){
        if(parts[i] === "M" || parts[i] === "F"){
            gender = parts[i];
            genderPos = i;
            break;
        }
    }

    if(genderPos === -1) return null;

    // Name is between Form number and Gender
    const nameParts = parts.slice(numbers[formIdx].pos+1, genderPos);
    const name = nameParts.join(" ");

    // Find College Code (pattern: 3-4 digits followed by colon)
    let collegeCode = "";
    let collegeName = "";
    let collegePos = -1;

    for(let i=genderPos+1; i<parts.length; i++){
        const match = parts[i].match(/^(\d{3,4}):(.*)/);
        if(match){
            collegeCode = match[1];
            collegeName = match[2];
            collegePos = i;
            break;
        }
    }

    // Category is between Gender and College Code
    let category = "";
    if(collegePos !== -1){
        const catParts = parts.slice(genderPos+1, collegePos);
        category = catParts.join(" ");

        // Get rest of college name
        if(collegePos < parts.length - 1){
            collegeName += " " + parts.slice(collegePos+1).join(" ");
        }
    } else {
        // No college code found, take rest as category
        const catParts = parts.slice(genderPos+1);
        category = catParts.join(" ");
    }

    return{
        sr: serial,
        air: air,
        neet: neet,
        form: form,
        name: name,
        gender: gender,
        category: category,
        college_code: collegeCode,
        college_name: collegeName
    };
}

/* ================= ENHANCED CATEGORY PARSER ================= */
function parseCategory(text){
    if(!text) return "OPEN";

    text = text.toUpperCase().trim();
    
    // Additional fixes for concatenated patterns
    text = text.replace(/\b(SEBC|SOBC|OBC|SC|ST|EWS|VJA|NTB|NTC|NTD|OPEN)(HA|W|D1|D2|D3|IQ|I\.Q\.|PWD|PH|EMD|EMR)\b/gi, "$1 $2");
    
    // Direct matches for common patterns
    const directMatches = {
        "OBC HA": "OBC HA", "OBC W": "OBC W", "OBC D1": "OBC D1", "OBC D2": "OBC D2", "OBC D3": "OBC D3",
        "SC HA": "SC HA", "SC W": "SC W", "SC D1": "SC D1", "SC D2": "SC D2", "SC D3": "SC D3",
        "ST HA": "ST HA", "ST W": "ST W", "ST D1": "ST D1", "ST D2": "ST D2", "ST D3": "ST D3",
        "SEBC HA": "SEBC HA", "SEBC W": "SEBC W", "SEBC D1": "SEBC D1", "SEBC D2": "SEBC D2", "SEBC D3": "SEBC D3",
        "SOBC HA": "SOBC HA", "SOBC W": "SOBC W", "SOBC D1": "SOBC D1", "SOBC D2": "SOBC D2", "SOBC D3": "SOBC D3",
        "EWS HA": "EWS HA", "EWS W": "EWS W", "EWS D1": "EWS D1", "EWS D2": "EWS D2", "EWS D3": "EWS D3",
        "VJA HA": "VJA HA", "VJA W": "VJA W", "VJA D1": "VJA D1", "VJA D2": "VJA D2", "VJA D3": "VJA D3",
        "OPEN HA": "OPEN HA", "OPEN W": "OPEN W", "OPEN D1": "OPEN D1", "OPEN D2": "OPEN D2", "OPEN D3": "OPEN D3",
        "OBC ORP-A": "OBC ORP-A", "OBC ORP-B": "OBC ORP-B", "OBC ORP-C": "OBC ORP-C", "OBC ORP": "OBC ORP",
        "SC ORP-A": "SC ORP-A", "SC ORP-B": "SC ORP-B", "SC ORP-C": "SC ORP-C", "SC ORP": "SC ORP",
        "ST ORP-A": "ST ORP-A", "ST ORP-B": "ST ORP-B", "ST ORP-C": "ST ORP-C", "ST ORP": "ST ORP",
        "SEBC ORP-A": "SEBC ORP-A", "SEBC ORP-B": "SEBC ORP-B", "SEBC ORP-C": "SEBC ORP-C", "SEBC ORP": "SEBC ORP",
        "SOBC ORP-A": "SOBC ORP-A", "SOBC ORP-B": "SOBC ORP-B", "SOBC ORP-C": "SOBC ORP-C", "SOBC ORP": "SOBC ORP",
        "NTC ORP-A": "NTC ORP-A", "NTC ORP-B": "NTC ORP-B", "NTC ORP-C": "NTC ORP-C", "NTC ORP": "NTC ORP",
        "NTB ORP-A": "NTB ORP-A", "NTB ORP-B": "NTB ORP-B", "NTB ORP-C": "NTB ORP-C", "NTB ORP": "NTB ORP",
        "NTD ORP-A": "NTD ORP-A", "NTD ORP-B": "NTD ORP-B", "NTD ORP-C": "NTD ORP-C", "NTD ORP": "NTD ORP",
        "VJA ORP-A": "VJA ORP-A", "VJA ORP-B": "VJA ORP-B", "VJA ORP-C": "VJA ORP-C", "VJA ORP": "VJA ORP",
        "EWS ORP-A": "EWS ORP-A", "EWS ORP-B": "EWS ORP-B", "EWS ORP-C": "EWS ORP-C", "EWS ORP": "EWS ORP",
        "OPEN ORP-A": "OPEN ORP-A", "OPEN ORP-B": "OPEN ORP-B", "OPEN ORP-C": "OPEN ORP-C", "OPEN ORP": "OPEN ORP",
        "ORP-A": "OPEN ORP-A", "ORP-B": "OPEN ORP-B", "ORP-C": "OPEN ORP-C", "ORP": "OPEN ORP"
    };

    // Clean up the text
    let cleanText = text.replace(/\(W\)/g, " W").replace(/\(EMD\)/g, " EMD").replace(/\(EMR\)/g, " EMR");
    cleanText = cleanText.replace(/\s+/g, " ").trim();

   
    // Token-based parsing for other cases
    const tokens = cleanText.split(/\s+/);
    let baseCategory = null;
    const categoryPriority = ["SOBC", "SEBC", "OBC", "SC", "ST", "EWS", "VJA", "NTB", "NTC", "NTD", "NRI", "OPEN"];

    for(const cat of categoryPriority){
        if(tokens.includes(cat) || cleanText.includes(cat)){
            if(cat === "OBC" && (cleanText.includes("SOBC") || cleanText.includes("SEBC"))) continue;
            baseCategory = cat;
            break;
        }
    }

    if(!baseCategory) baseCategory = "OPEN";

    // Extract modifiers
    const modifiers = [];

    if(tokens.includes("ORP-A") || cleanText.includes("ORP-A")) modifiers.push("ORP-A");
    else if(tokens.includes("ORP-B") || cleanText.includes("ORP-B")) modifiers.push("ORP-B");
    else if(tokens.includes("ORP-C") || cleanText.includes("ORP-C")) modifiers.push("ORP-C");
    else if(tokens.includes("ORP") || cleanText.includes("ORP")) modifiers.push("ORP");

    if(tokens.includes("HA")) modifiers.push("HA");
    if(tokens.includes("I.Q.") || tokens.includes("IQ")) modifiers.push("I.Q.");
    if(tokens.includes("D1")) modifiers.push("D1");
    if(tokens.includes("D2")) modifiers.push("D2");
    if(tokens.includes("D3")) modifiers.push("D3");
    if(tokens.includes("PWD") || tokens.includes("PH")) modifiers.push("PWD");
 
    // Sort and join
    const orderMap = {
        "ORP-A":1, "ORP-B":2, "ORP-C":3, "ORP":4,
        "HA":5, "W":6, "I.Q.":7, 
        "D1":8, "D2":9, "D3":10, 
        "EMD":11, "EMR":12, "PWD":13
    };
    
    const uniqueModifiers = [...new Set(modifiers)].sort((a,b)=>(orderMap[a]||99)-(orderMap[b]||99));

    let result = baseCategory;
    if(uniqueModifiers.length > 0){
        result += " " + uniqueModifiers.join(" ");
    }

    return result;
}

/* ================= COLLEGE NAME CLEANER ================= */
function cleanCollegeName(name){
    if(!name) return "";

    let cleaned = name.replace(/\s+/g, " ")
                     .replace(/\bM C\b/g, "MC")
                     .replace(/\bG M C\b/g, "GMC")
                     .replace(/\bG DC\b/g, "GDC")
                     .trim();

    const stopWords = [
        "G OVERNMENT OF MAHARASHTRA", "ORPHANC", "ORPHAN", "(No Pref)", "(No", 
        "(Ret.)", "(No Change)", "STATE COMMON ENTRANCE", "ADMISSIONS TO HEALTH", 
        "NEET(UG)", "PROVISIONAL SELECTION", "PRINTED ON", "LEGENDS", "AIR:", 
        "Cat:", "Choice Not Available", "Not Available", "Not Provided", 
        "No College", "N/A", "NIL", "NULL", "---", "--", "TO BE ALLOTTED",
        "NOT ALLOTTED", "NOT ASSIGNED", "GOVT.", "GOVERNMENT"
    ];

    for(let stop of stopWords){
        const idx = cleaned.toUpperCase().indexOf(stop.toUpperCase());
        if(idx !== -1){
            cleaned = cleaned.substring(0, idx).trim();
        }
    }

    // Remove trailing special characters and numbers
    cleaned = cleaned.replace(/[\s\-–—]+$/, "");
    cleaned = cleaned.replace(/\s+\d+\s*$/, "");
    
    return cleaned;
}

function downloadCSV(){
    if(extractedData.length === 0) {
        alert("No data to download!");
        return;
    }

    let csv="AIR,Gender,Category,College Code,College Name\n";
    extractedData.forEach((r, i)=>{
        csv+=`${r.air},${r.gender},"${r.category}",${r.collegeCode},"${r.collegeName}"\n`;
    });

    const blob=new Blob([csv],{type:"text/csv;charset=utf-8;"});
    const a=document.createElement("a");
    const timestamp = new Date().toISOString().slice(0,19).replace(/[:T]/g, '-');
    a.href=URL.createObjectURL(blob);
    a.download=`neet_cap_data_${timestamp}.csv`;
    a.click();
}

function clearTable(){
    extractedData=[];
    document.getElementById("tableBody").innerHTML="";
    document.getElementById("dataTable").style.display="none";
    document.getElementById("status").innerText="Select PDF to begin";
    document.getElementById("status").className="loading";
    document.getElementById("downloadBtn").disabled=true;
    document.getElementById("pdfFile").value="";
}
</script>

</body>
</html>
